### 실행 컨텍스트

코드를 실행하는데 필요한 조건이나 상태를 모아둔 객체 (변수, 함수, 변수의 유효범위(Scope), this)

효율적인 식별자 결정을 하기 위한 수단으로 사용된다

자바스크립트를 실행시키면 콜 스택에  **전역 실행 컨텍스트**를 생성한다

이후에 함수를 호출할 경우  **함수 실행 컨텍스트**가 생성되어 콜스택에 적재된다

콜 스택은 LIFO방식으로 동작하므로 가장 최근 실행 컨텍스트만 활성화된다

함수 실행 컨텍스트는 함수 실행 완료시 사라지고  전역 실행 컨텍스트는 페이지 종료시 사라진다

실행 컨텍스트의 Lexical Environment 에는 Environment Record(환경 레코드) & Outer Environment Reference (외부 환경 참조)가 있다

**Environment Record**  (환경 레코드)

- 식별자와 식별자에 바인딩 된 값을 기록하는 공간이다

- 자바스크립트는 실행 전에 전체코드를 스캔해서 변수같은 정보들을 환경 레코드에 작성해놓는 호이스팅이란 작업을 진행한다

- 호이스팅은 선언문을 모두 최상단으로 끌어올리는 듯한 현상으로  변수 호이스팅과  함수 호이스팅으로 나눠서 설명할 수 있다

**변수 호이스팅**

- var : 선언과 초기화를 동시에 (undefined)

- let,  const : 선언만하고 초기화하지 않는다, 선언문 라인 이전에 사용할 수 없다

선언라인 이전에 식별자를 참조할 수 없는 구역 : TDZ(Temporal Dead Zone) - 일시적 사각 지대

**함수 호이스팅**

- 함수 표현식 : 함수를 변수에 담고있기 때문에 변수 호이스팅과 똑같이 동작함

- 함수 선언식 : 선언과 동시에 완성된 함수 객체를 생성해서 환경레코드에 기록하므로 선언문 라인 이전에 사용할 수 있다

**Outer Environment Reference** (외부 환경 참조)

- 외부 Lexical Environment를 참조하는 포인터로 스코프 중첩 구조에서 스코프 탐색을 위해 사용한다

- 현재 실행 컨텍스트의 Scope에 없다면 상위 실행 컨텍스트의 Scope를 찾는 과정을 반복하다가 발견하면 결과를 반환하고

없다면 최상단의 실행 컨텍스트인 전역 실행 컨텍스트를 조사한 뒤 결과를 반환한다

**Scope**

- 식별자의 접근 규칙에 따른 유효범위
- 범위는 중괄호(블록)또는 함수에 의해 나눠진다

- var는 함수스코프 (함수내부를 제외한 위치에서 선언시 global scope에 할당)
- let과 const는 블록스코프 (블럭의 위치에 따라 scope할당)

- 스코프는 중첩이 가능하고 안쪽에서 바깥쪽 스코프로 접근할 수 있다 
  (Lexical환경의 외부환경참조를 통해)
- 가장 바깥쪽의 스코프를 전역 스코프라 부르고 여기에 선언된 변수는 전역 변수 라고한다
- 전역을 제외한 위치의 스코프를 지역스코프라 하고 여기에 선언된 변수는 지역 변수라고 한다

**Closure**

- 내부 함수가 외부함수의 Context에 접근할 수 있는 것

- [ ] 브라우저 동작 원리 
  <details>
  <summary>접기</summary>

  1. tcp/ip연결을 하고 http통신이 이루어지면 HTML을 가장 먼저 가져오고 **렌더링 엔진**을 통해 파싱한다

  2. 렌더링 엔진의 HTML파서는 HTML을 파싱해서 **DOM트리**를 만들게되는데 이때 Link태그를 만나 StyleSheet를 내려받게 되면 CSS파서가 CSS파싱을 해서 **CSSOM트리**를 만들게 된다

  3. DOM트리와 CSSOM트리를 결합해서 **렌더트리**를 만들고 렌더링이 이루어진다

  4. HTML파서가 `<script>`태그를 만나면 **DOM파싱을 중단**하고 JS엔진에 제어권한을 넘겨 결과 값을 받는다  
      - JS엔진은 script태그 내부의 코드 혹은 src attribute에 정의된 js파일을 로드하고 파싱 및 기계어 컴파일한다
      - 브라우저는 동기적으로 HTML CSS JS를 처리하기 때문에 script태그의 위치에 따라 **DOM생성이 지연될 수 있다**
      - 위와같은 문제를 async나 defer를 통해 해결할 수 있다

  5. 생성된 DOM 노드의 레이아웃 수치 변경시 영향을 받는 모든 노드의 수치를 재계산해서 렌더트리를 재생성한다(Reflow), 이후에 재생성된 렌더트리를 다시 그린다(Repaint)
  이 때 레이아웃 수치에 영향을 끼치지 않는것은 Repaint과정만 진행된다
  </details>
