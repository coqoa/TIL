### 1. Process와 Thread의 차이
  <details>  
  <summary></summary>
  
  프로세스는 운영체제로부터 **자원을 할당**받는 '작업'의 단위고 스레드는 프로세스가 할당받은 **자원을 사용**하는 '실행'의 단위다  
  
  프로세스는 **독립적으로** 메모리 공간을 할당받기 때문에 프로세스간 자원을 공유하지도 않고 영향을 끼치지도 않는다
  프로세스간 통신을 위해선 IPC라는 특수한 통신 기법을 사용해야하고, 잦은 컨텍스트 스위칭으로 인해 **비용이 발생**한다는 단점이 있다
  
  스레드는 메모리의 **Stack영역을 각각 할당**받고 Code, Data, Heap영역은 서로 공유한다.  
  컨텍스트 스위칭이 감소하면서 자원을 할당하는 시스템 콜이 줄어들어 **시스템 자원 소모가 줄고**, 공유자원을 통한 **처리비용 감소 및 처리량 증가** 등의 장점이 있지만,  
  **자원 공유로 인한 Race Condition Issue 등의 문제**가 발생할 수 있고,  
  하나의 스레드에서 발생한 문제가 다른 이웃 스레드에도 **영향을 끼칠 수 있다**는 단점이 있다
  
    
    
  </details>

---
### 2. Race Condition
  <details>  
  <summary></summary>
  
    
  </details>

---

### 3. 메모리의 역할
  <details>  
  <summary></summary>
  
  메모리는 대표적으로 RAM과 ROM으로 구분할 수 있다  
  RAM은 Random Access Memory의 줄임말로 이름에서 알 수 있듯이  
  임의의 영역에 접근하여 읽기 / 쓰기를 할 수 있는 휘발성 메모리이며 어느 위치의 데이터에 접근하든 동일한 시간이 걸린다는 특징이 있다   
  CPU의 처리에 의한 결과나 처리해야 할 데이터를 준비하는 용도로 사용한다
  
  ROM은 Read Only Memory의 약자로 읽기만 가능한 비휘발성 메모리이다  
  변경 가능성이 없는 시스템 소프트웨어를 저장하는데 주로 사용하고  
  삭제나 수정을 위해선 특수한 방법을 사용해야한다.
  
  </details>

---

### 4. 비동기 프로그래밍이란
  <details>  
  <summary></summary>
  
  비동기 프로그래밍은 시간일 걸리는 작업이 끝나지 않은 상태에서 다음 작업을 요청하여 non-block방식으로 처리하는 프로그래밍 기법이다
  Callback함수, Promise, await / async를 통해 구현할 수 있다
  

  **Callback함수**는 함수의 인자로 들어가는 함수를 말하며 어떤 함수를 사용하냐에 따라 동기적 / 비동기적으로 선택해서 구현할 수 있다
  간편하지만 중첩이 과해지면 가독성도 안좋고 유지보수도 힘들어지는 Callback지옥을 만날 수 있다
  
  **Promise**는 비동기 작업의 결과에 따라 표준화된 방식으로 처리한다  
  resolve와 reject라는 인자를 받고 성공시 then을 통해 resolve를, 실패시 catch를 통해 reject를, finally를 통해 성공 / 실패에 상관없는 결과값을 호출할 수 있다  
  promise를 반환하기 때문에 promise chaining이 가능하지만 이 역시 중첩이 과하면 Callback지옥과 유사한 경험을 할 수 있다  
  
  **async / await**을 통해 비동기를 동기적으로 보이게 해서 Promise를 단순화할 수 있다  
  async 함수 내부에서 await 사용을 통해 구현할 수 있고 예외처리는 try/catch문으로 한다  
  promise를 반환하기 때문에 await, then 등을 붙일 수 있고 사용법에 따라 동기적 / 비동기적으로 처리할 수 있다
  
  </details>

---
### 5. 자료구조란?
  <details>    
  <summary></summary>
  
  자료구조는 데이터를 효율적으로 사용하기위해 체계적으로 저장하기 위한 방식으로  
  정수, 실수 같은 자료형을 나타내는 단순 구조,  
  배열, 연결리스트, 스택, 큐 등등의 선형 구조,  
  그래프, 트리같은 비선형 구조,  
  그리고 파일구조가 있다  
  
  **배열** : 가장 기본적인 자료구조로 동일한 타입의 데이터가 연속적으로 있고 Index를 통해 접근할 수 있다  
  **연결 리스트** : 데이터와 포인터로 이루어진 노드들이 연결되어 리스트를 이루는 자료 구조로 단일 연결리스트, 이중 연결 리스트, 원형 연결 리스트가 있다  
  **스택** : LIFO 방식으로 동작하는 자료 구조  
  **큐** : FIFO 방식으로 동작하는 자료 구조  
  
  **트리** : root노드로 부터 뻗어나오는 child노드로 이뤄진 계층적 자료구조  
  **그래프** : 노드와 간선을 하나로 모은 자료구조로 객체간의 관계 표현이 가능하다, 무방향 그래프와 방향 그래프로 나뉜다
  </details>

---
### 6. 자바스크립트에서 this란?
  <details>    
  <summary></summary>
  
  this는 호출하는 위치에 따라 다른 값을 반환하는 '자기 참조 변수'다  
  일반적으로는 window 객체를 반환하지만 예외 사항이 있다
  1. 일반 함수 : 전역에 선언된 일반 함수는 window객체의 메소드이므로 window를 가리킴
  2. 화살표 함수 : 외부 함수의 this
  3. 생성자 함수 : new를 통해 생성된 객체
  4. 객체의 메서드 : 메서드 자신을 호출한 객체
  5. addEventListener : HTML요소
  6. strict모드 : undefined
  
  </details>

---
### 7. 함수와 메소드의 차이
  <details>    
  <summary></summary>
  
  함수는 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드의 집합이다
  메소드는 클래스내부에 정의된 함수를 뜻한다
  </details>

---
### 8. REST API란  
  <details>  
  <summary></summary>
  
  REST는 'REpresentational State Transfer'의 약자로 직역하자면 "표현적인 상태 전달"이고 API는 소프트웨어간 지정된 방식으로 통신하기 위한 수단이다  
  즉 '표현적인 상태 전달을 통해 소프트웨어간 통신하는것'이 REST스러운 API라 할 수 있고 이는 HTTP프로토콜을 HTTP프로토콜답게 사용하기 위한 수단이라고 볼 수 있다   
  CRUD같은 행위를 표현하기 위한 'HTTP Method'와 리소스 식별을 위한 'URI'의 조합을 통해 응답코드를 받을 수 있다
  - HTTP Method는 POST, GET, PUT/PATCH, DELETE가 있다
      - POST : 리소스 생성
      - GET : 리소스 요청
      - PUT : 전체 업데이트
      - PATCH : 부분 업데이트
      - DELETE : 삭제

  - GET과 POST의 차이
      - GET은 리소스 요청을 위해 사용한다  
  캐쉬될 수 있고 브라우저 기록이 남으며 북마크로 추가도 가능하다  
  데이터 길이에 제한이 있고 쿼리 스트링 방식으로 전달되며 응답코드로 200(ok)을 받는다

      - POST는 리소스 생성이나 업데이트를 위해 사용한다  
  GET과는 반대로 캐시될수 없고 브라우저 기록도 안남으면 북마크 추가도 불가능하다  
  데이터 길이에 제한이 없고 HTTP BODY에 담겨 전달되고 응답코드는 201(create)을 받는다

  </details>
  
---

### 9. 브라우저 동작 원리
  <details>  
  <summary></summary>
  
  브라우저는 요청을 통해 서버로부터 HTML파일을 먼저 받아온다  
  렌더링 엔진이 HTML파서를 통해 파싱해서 **DOM트리**를 만든다
  `<link>`태그를 통해 StyleSheet를 받으면 렌더링 엔진의 CSS파서가 파싱해서 **CSSOM트리**를 만든다  
  DOM트리와 CSSOM트리를 합쳐 **렌더 트리**를 만들고 렌더링한다
  
  HTML파싱중에 `<script>`태그를 만나면 HTML파서는 파싱을 중지하고 JS엔진으로 제어권을 넘긴다  
  JS엔진은 `<script>`태그 내부의 코드나 src attribute에 정의된 JS코드를 로드, 파싱, 컴파일 하는 과정을 거친 후 HTML파서로 제어권을 넘긴다
  
  위에서 설명했듯이 HTML파싱중 `<script>`태그를 만나면 파싱을 멈추기 때문에 `<script>`태그를 `<body>`태그 최하단에 배치하거나 async 또는 defer같은 속성을 사용하도록 해야 한다
  
  </details>

---

### 10. 자바스크립트의 동작 원리
  <details>  
  <summary></summary>
  
  자바스크립트는 싱글스레드 언어지만 Web API를 통해 비동기 작업을 처리한다  
  작업들은 콜스택에 적재되어 LIFO 방식으로 처리되는데 시간이 필요한 작업은 Web API로 넘기고 다음 작업을 처리한다  
  Web API에서 작업이 끝나면 결과를 콜백큐에 넣어주고 이는 FIFO방식으로 처리되며 처리시기는 이벤트루프가 결정한다  
  스택의 작업이 끝나고 비었을 때 이벤트루프에 의해 큐의 첫번째 콜백이 스택으로 들어가서 작업을 처리한다  
  
  </details>

---

### 11. Execution Context - 실행 문맥
  <details>  
  <summary></summary>
  
  실행문맥은 코드를 실행하기 위한 조건이나 상태를 모아놓은 객체다  
  자바스크립트를 실행하면 콜 스택에 **전역 컨텍스트**가 생성되고 이는 자바스크립트 종료시 사라진다  
  이후에 함수를 호출하면 콜 스택에 **함수 컨텍스트**를 적재하고 콜스택은 이를 LIFO방식으로 처리하며 함수 호출 완료시 함수컨텍스트는 사라진다  
  실행문맥은 Scope를 참조하고 Lexical환경을 통해 호이스팅, 클로저 기능을 사용한다
  
  </details>

---

### 12. Scope
  <details>  
  <summary></summary>
  
  Scope는 변수의 유효범위를 뜻한다  
  전역 스코프와 지역 스코프 두 타입이 존재한다  
  전역 스코프에 선언된 변수를 전역 변수라 하는데 전역에 선언되어 어느 곳에서든 해당 변수에 접근할 수 있다  
  지역 스코프에 선언된 변수를 지역 변수라 하고 해당 지역과 하위지역에서만 참조할 수 있다  
  
  자바스크립트는 함수 레벨 스코프를 따른다  
  var 키워드를 이용하면 전역 스코프에 할당되고 함수 내부에 사용시 지역스코프에 할당 되는것을 확인할 수 있고  
  ES6에서 추가된 let과 const를 이용하면 블록 레벨 스코프를 구현할 수 있다  
  ```
  * 함수 레벨 스코프 : 함수 내부를 제외한 곳에서 선언하면 Global scope 할당, 함수 내부는 Local Scope  
  * 블럭 레벨 스코프 : 선언한 위치에 따라 scope 할당  
  ```
  
  </details>

---

### 13. Closure
  <details>  
  <summary></summary>
  
  클로저에 대한 MDN의 설명은 다음과 같다  

  ```
  	클로저는 함수와 함수가 선언된 Lexical환경의 조합이다
  	즉, 클로저는 내부 함수에서 외부 함수로 접근하기 위한 방법을 제공한다
  ```

실행 문맥의 Lexical환경에는 `Environment Record(환경레코드)`와 `Outer Environment Reference (외부 환경 참조)`가 있다.  
  `환경 레코드`는 식별자와 식별자에 바인딩된 값을 기록해두는 객체이고  
  `Outer`는 외부 Lexical환경을 참조하는 포인터로 스코프 중첩 구조에서 스코프 탐색을 위해 사용한다  
  즉, 클로저는 함수와 Lexical환경의 조합을 통해 내부 함수에서 외부함수로 접근할 수 있도록 하는, 효율적인 식별자 결정을 위한 수단이다.  
  
  </details>

---
### 14. Hoisting
  <details>  
  <summary></summary>
  
  호이스팅은 선언문이 유효범위의 최상단으로 끌어올려지는듯한 현상을 말한다  
  자바스크립트는 함수를 실행하기 전 전체코드를 스캔해서 얻은 '변수와 같은 정보'를 환경레코드에 기록해둔다  
  * 환경 레코드 : 실행 문맥의 Lexical 환경에 있다,식별자와 식별자에 바인딩 된 값을 기록해둔 객체이다
  호이스팅은 변수 호이스팅과 함수 호이스팅으로 나눠서 설명할 수 있다  
  
### 변수 호이스팅  
* TDZ (Temporal Dead Zone) - 호이스팅 된 후부터 선언라인 이전까지 접근할 수 없는 영역 (일시적 사각지대)
  - #### var  
	호이스팅 되면서 초기화 되기 때문에 TDZ가 없고 선언문 라인 이전에 접근 시 undefined를 반환한다
  - #### let, const
	호이스팅은 되지만 초기화는 각각 선언문 라인에서 이뤄지기 때문에 TDZ가 존재한다
    선언문 라인 이전에 접근 시 Reference Error가 발생한다
  
### 함수 호이스팅
  - #### 함수 표현식  
	변수에 할당하기 때문에 변수 호이스팅과 동일하게 동작한다
  - #### 함수 선언식
	함수 선언과 동시에 환경 레코드에 완성된 함수 객체를 기록하기 때문에 선언문 라인 이전에도 사용할 수 있다
  
  </details>

---
### 15. var, let, const
  <details>  
  <summary></summary>
  
  - var : 재선언 / 재할당 가능, 함수 스코프
  - let : 재선언 불가능, 재할당 가능, 블럭 스코프
  - const : 재선언 불가능, 재할당 불가능, 블럭스코프
  
  - #### var를 안 쓰는 이유?
  	- 재선언이 가능하기 때문에 의도치 않은 곳에서 중복되는 이슈가 발생할 수 있다
  	- 함수 스코프의 범위를 가지기 때문에 의도치 않게 전역변수를 사용할 여지가 있는데 이는 성능 하락은 물론 유지보수가 힘들어 진다는 단점이 생긴다 
  
  </details>

---  

### 16. 브라우저 저장소
  <details
  <summary></summary>
  HTTP는 비연결성과 무상태성이란 특징이 있다   
  ```
  	- 비연결성 : 서버는 클라이언트의 요청에 대한 응답을 보내고 접속을 끊는다  
  	- 무상태성 : 상태정보를 유지하지 않는다  
  ```
  이런 특징덕분에 자원 낭비가 줄어드는 장점이 있지만 통신을 할 때마다 새로 연결해줘야하는 단점이 생긴다  
  이를 해결하기 위해 쿠키와 웹스토리지 같은 브라우저 저장소를 사용한다  
  
#### 쿠키  
	- 서버에서 생성하고 클라이언트에 저장되는 작은파일로 HTTP헤더에 담아서 요청 및 응답 한다  
	- 클라이언트에서 HTTP요청시 서버는 헤더에서 쿠키를 확인하고 없다면 생성, 있으면 변경된 상태 정보를 수정한 뒤 HTTP헤더에 담아서 응답한다   
	- 만료일을 지정한 쿠키를 영구쿠키라 하고 이는 브라우저를 닫아도 삭제되지 않는다   
	- 만료일을 지정하지 않은 쿠키를 세션쿠키라 하고 이는 브라우저를 닫으면 삭제된다  
	- 쿠키는 저장 용량이 작고 보안에 취약하며 매번 서버에 전송되기 때문에 불필요한 트래픽이 발생한다는 단점이 있다  

#### 세션
	- 세션은 쿠키를 기반으로 하지만 사용자 정보를 서버에 저장하고 관리한다
	- 클라이언트 요청시 서버의 세션DB에 리소스를 생성하고 세션ID를 발급한 뒤 쿠키에 포함해서 응답한다
	- 이후부터는 요청시 받은 쿠키에서 세션ID를 확인해서 세션DB의 데이터를 응답한다
	- 즉, 쿠키를 세션ID 전달 매개체로만 사용해서 되어 쿠키에 비해 보안성이 좋아졌다  
	- 하지만 이 역시 보안에 취약하므로 민감한 데이터는 서버측에서 암호화하는 과정이 필요하다
	- 또, 세션이 늘어날 수록 서버에 차지하는 비중이 늘어나고 서버 과부하의 원인이 될 수 있다

- POMOTODO 암호화

- 웹스토리지  
	- 
- 
  </details>

---
