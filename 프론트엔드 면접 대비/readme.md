
<details>  
<summary> 1. Process와 Thread의 차이</summary>
<br>
	
**프로세스**는 운영체제로부터 `자원을 할당`받는 '작업'의 단위로 `개별적인 메모리 공간`을 할당받는다  
둘 이상의 프로세스로 구성해서 작업을 처리하는 **멀티 프로세스**는  
서로 자원을 공유하지 않는 `독립적인 구조` 덕분에 `안정성`이 높다는 장점이 있지만,  
컨텍스트 스위칭시 발생하는 `오버헤드`가 쓰레드에 비해 무겁고,  
프로세스간 통신하려면 `IPC`라는 특수한 통신 기법을 사용해야한다는 단점이 있다

**쓰레드**는 프로세스가 할당받은 `자원을 사용`하는 '실행'의 단위로 메모리의 `Stack영역은 개별적으로 할당`받고 Text, Data, Heap 영역은 서로 `공유`한다  
하나의 프로세스에서 여러 쓰레드가 자원을 공유하며 작업을 처리하는 **멀티 쓰레드**는  
시스템 콜이 줄어 `시스템 자원 소모가 줄고`, 공유 자원을 통한 `처리 비용 감소` 및 `처리량 증가`의 장점이 있지만,  
`자원 공유`로 인한 문제가 발생할 수 있고,  
한 쓰레드의 문제가 `다른 쓰레드에도 영향을 끼칠 수 있다`는 단점이 있다.	
</details>
 
<details>  
<summary> 2. 이벤트 버블링 / 캡쳐링</summary>
<br>  
	
이벤트 버블링은 `한 요소에서 이벤트 발생시 할당된 핸들러가 동작하고, 최상위 요소까지 연속해서 각각의 핸들러가 동작`하는 흐름이다.  

이벤트 캡처링은 버블링과 반대로 `최하위 요소까지 연속해서 각각의 핸들러가 동작하는 흐름`이고  
addEventListener의 `capture`옵션을 `true`로 변경해서 사용한다.  

이벤트 버블링은 `<html>`요소를 거쳐 `document`객체를 만날 때 까지 진행된다  
이벤트 버블링을 막고싶으면 event객체의 `stopPropagation()`메소드를 사용하면 되는데  
만약 한 요소의 이벤트를 처리하는 핸들러가 `여러개`일 경우 하나를 멈춰도 다른 핸들러는 동작하기 때문에  
`stopImmediatePropagation()`메소드를 사용하야 한다

이벤트 버블링과 캡쳐링을 이용해서 `이벤트 위임`을 구현하면  
이벤트 핸들러를`상위요소에서 한번에 관리`할 수 있고,  
사용자의 인터렉션에 의해 추가되는 `아직 만들어지지 않은 요소에 이벤트를 등록`하는 등  
비슷한 방식으로 여러 요소를 다룰 수 있다
	
- 이벤트 핸들러 : 이벤트가 발생했을 때 실행되는 함수
- 이벤트 핸들러 할당  
: HTML방식 ,DOM 프로퍼티 방식, `addEventListener(...)`,  
	```javascript
	//HTML방식
	<input value="클릭해 주세요." onclick="alert('클릭!')" type="button"> // 복수할당 불가능
	
	//DOM 프로퍼티 방식
	<input type="button" id="button" value="클릭해 주세요.">
	<script>
	  button.onclick = function() {
	    alert('클릭!');
	  };
	</script> // 복수의 핸들러 할당시 덮어씀
	```
- 이벤트 핸들러 제거 : `removeEventListener(...)`
- event.target : 이벤트가 발생한 가장 안쪽 요소(= 실제 이벤트가 시작된 요소)
- event.currentTarget : '현재' 실행중인 핸들러가 할당된 요소
- event.eventPhase : 현재 이벤트 흐름 단계(캡쳐링=1, 타깃=2, 버블링=3)

	
	
</details>

<details>  
<summary> 4. 메모리의 역할</summary>
<br>  
	
메모리는 대표적으로 RAM과 ROM으로 구분할 수 있다  
RAM은 Random Access Memory의 줄임말로 이름에서 알 수 있듯이  
임의의 영역에 접근하여 읽기 / 쓰기를 할 수 있는 `휘발성 메모리`로  
어느 위치의 데이터에 접근하든 `동일한 시간`이 걸린다는 특징이 있다   
CPU의 처리에 의한 결과나 현재 필요한 데이터, 가까운 미래에 필요할 것 같은 데이터를 준비하는 용도로 사용한다

ROM은 Read Only Memory의 약자로 읽기만 가능한 비휘발성 메모리이다  
변경 가능성이 없는 시스템 소프트웨어를 저장하는데 주로 사용하고  
삭제나 수정을 위해선 특수한 방법을 사용해야한다.
</details>

<details>  
<summary> 5. 비동기 프로그래밍이란</summary>
<br>  
	
비동기 프로그래밍은 시간일 걸리는 작업이 끝나지 않은 상태에서 다음 작업을 요청하여  
non-block방식으로 처리하는 프로그래밍 기법이다. 
Callback함수, Promise, await / async를 통해 구현할 수 있다

**Callback함수**는 함수의 인자로 들어가는 함수를 말하며 어떤 함수를 사용하냐에 따라 동기적 / 비동기적으로 선택해서 구현할 수 있다
간편하게 사용할 수 있지만 중첩이 과할경우 가독성도 안좋고 유지보수도 힘들어지는 Callback지옥을 만날 수 있다

**Promise**는 비동기 작업의 처리 결과에 따라 표준화된 방식으로 처리한다  
resolve와 reject라는 인자를 받고 성공시 then을 통해 resolve를, 실패시 catch를 통해 reject를, finally를 통해 성공 / 실패에 상관없는 결과값을 호출할 수 있다  
promise를 반환하기 때문에 promise chaining이 가능하지만 이 역시 중첩이 과하면 Callback지옥과 유사한 경험을 할 수 있다  

**async / await**을 통해 비동기를 동기적으로 보이게 해서 Promise를 단순화할 수 있다  
async 함수 내부에서 await 사용을 통해 구현할 수 있고 예외처리는 try/catch문으로 한다  
promise를 반환하기 때문에 await, then 등을 붙일 수 있고 사용법에 따라 동기적 / 비동기적으로 처리할 수 있다
  
</details>

<details>    
<summary> 6. 자료구조란? </summary>
<br> 
	
  자료구조는 데이터를 효율적으로 사용하기위해 체계적으로 저장하기 위한 방식으로  
  정수, 실수 같은 자료형을 나타내는 단순 구조,  
  배열, 연결리스트, 스택, 큐 등등의 선형 구조,  
  그래프, 트리같은 비선형 구조,  
  그리고 파일구조가 있다  
  
  **배열** : 동일한 타입의 데이터가 연속적으로 있는 가장 기본적인 자료구조, Index를 통해 접근할 수 있다  
  **연결 리스트** : 데이터와 포인터로 이루어진 노드들이 연결되어 리스트를 이루는 자료 구조, 단일 연결리스트, 이중 연결 리스트, 원형 연결 리스트가 있다  
  **스택** : 후입선출(LIFO) 방식으로 동작하는 자료 구조  
  **큐** : 선입선출(FIFO) 방식으로 동작하는 자료 구조  
  
  **트리** : root노드로 부터 뻗어나오는 child노드로 이뤄진 계층형 자료구조  
  **그래프** : 그래프는 노드와 간선을 하나로 모은 망형 자료구조로 객체간의 관계를 표현할 수 있고 무방향 그래프와 방향 그래프로 나뉜다
</details>

<details>    
<summary>7. 함수와 메소드의 차이</summary>
<br>  
	
  함수는 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드의 집합이다  
  메소드는 클래스 내부에 정의된 함수를 뜻한다
</details>
  
<details>  
<summary> 8. REST API란 </summary>
<br>  
	
REST는 'REpresentational State Transfer'의 약자로 직역하자면 `표현적인 상태 전달`이고  
API는 `소프트웨어간 지정된 방식으로 통신하기 위한 수단`이다  
즉 `표현적인 상태 전달을 통해 소프트웨어간 통신하는것`이 REST스러운 API라 할 수 있고   
CRUD같은 행위를 표현하기 위한 'HTTP Method'와 리소스 식별을 위한 'URI'의 조합을 통해 구현할 수 있고 결과로 응답코드를 받을 수 있다 
 
- HTTP Method는 POST, GET, PUT/PATCH, DELETE가 있다
- POST : 리소스 생성
- GET : 리소스 요청
- PUT : 전체 업데이트
- PATCH : 부분 업데이트
- DELETE : 삭제
- URI의 규칙은 `소문자`의 `명사`를 `복수형`으로 사용하고 `하이픈`을 사용하며 `파일 확장자는 포함시키지 않도록 한다`  
계층관계는 `슬래시`로 구분하지만 `마지막에는 슬래시를 포함시키지 않는다`

  - GET과 POST의 차이
      - GET은 `리소스 요청`을 위해 사용한다  
  캐쉬될 수 있고 브라우저 기록이 남으며 북마크로 추가도 가능하다  
  데이터 길이에 제한이 있고 `쿼리 스트링` 방식으로 전달되며 응답코드로 200(ok)을 받는다

      - POST는 `리소스 생성이나 업데이트`를 위해 사용한다  
  GET과는 반대로 캐시될수 없고 브라우저 기록도 안남으면 북마크 추가도 불가능하다  
  데이터 길이에 제한이 없고 `HTTP BODY`에 담겨 전달되고 응답코드는 201(create)을 받는다

</details>
  
<details>  
<summary> 9. 브라우저 동작 원리 </summary>
<br>  
	
브라우저의 로딩과정은 `파싱` - `스타일` - `레이아웃` - `페인트` - `합성` - `렌더`순으로 진행되는데  
`스타일` ~ `합성`까지의 단계를 렌더링이라 한다
1. <B>파싱</B> - HTTP통신을 통해 받은 `HTML파일`을 HTML파서로 파싱해서 `DOM트리`를 만들고  
CSS파서로 `StyleSheet`를 `CSSOM트리`로 만드는 단계
2. <B>스타일</B> - `파싱 결과물의 스타일을 매칭`시켜서 `렌더트리를 구성`하는 단계
3. <B>레이아웃</B> - 기기의 뷰포트 내에서 노드의 `정확한 위치나 크기를 계산하는 과정`으로 경우에 따라 `'reflow'`라고도 한다
4. <B>페인트</B> - 렌더트리의 각 노드를 `화면의 실제 픽셀로 변환하는 단계`로 `위치와 관계없는 CSS속성`을 적용한다
5. <B>합성</B> - 화면에 표시하기 위해 페이지에 페인트 된 부분을 합치는 과정

렌더링은 상황에 따라 반복이 될 수 있고 성능을 많이 잡아먹는다  
DOM이 추가혹은 삭제될때, 기하학적 변화가 있을때는 <B>reflow</b>가 발생하고  
기하학적 변화 없이 CSS가 변경되는 상황에는 <b>repaint</b>가 발생한다  

HTML파서는 파싱중에 `<script>`태그를 만나면 DOM파싱을 중단하고 자바스크립트 엔진에게 제어권한을 넘긴다  
자바스크립트 엔진은 `<script>`태그 내부 혹은 src 속성에 정의된 js파일을 로드, 파싱, 컴파일하는 괴정을 거친 후 HTML파서에게 제어권한을 넘긴다  
`<script>`태그를 만나면 HTML파서가 중단된다는 문제가 있기 때문에 `<body>`태그 최하단에 `<script>`태그를 작성하거나 `async` 혹은 `defer` 속성을 이용해서 문제를 해결한다  
</details>

<details>  
<summary> 3. SPA와 SSR</summary>
<br>  
	
<b>SPA</b>는 Single Page Application의 약자로 `Client Side Rendering 방식`을 사용한다  
클라이언트 사이드 렌더링은 서버로부터 빈 뼈대 HTML파일을 받은 뒤 자바스크립트 코드를 통해  
동적으로 DOM을 생성하고 렌더링한다  
클라이언트에서 작업을 처리하기 때문에 `서버의 부담이 줄어들`고, `깜빡임이 없어져` 사용자 경험이 좋아지고,  
새로운 요청이 있으면 `변경해야할 부분만 갱신`하기 때문에 구동속도가 빨라지고 `TTV와 TTI의 간극이 없다`는 장점이 있지만. 
`초기 로딩`이 오래걸리고 `검색엔진최적화`에 좋지 않다는 단점이 있다  

<b>SSR</b>은 Server Side Rendering의 줄임말로 `Multi Page Application`의 렌더링 방식이다  
`초기 로딩`이 빠르고 `검색 엔진 최적화`에 유리하지만  
`깜빡임 이슈`가 있고 `서버 과부하`가 될 수 있으며 HTML렌더를 통해 View는 가능하지만  
자바스크립트 로직을 연결해야 Interaction이 가능하기 때문에 `TTV와 TTI간에 공백기간`이 존재한다는 단점이 있다    
</details>

<details>  
<summary>10. 자바스크립트의 동작 원리</summary>
<br>  
	
  자바스크립트는 싱글스레드 언어지만 Web API를 통해 비동기 작업을 처리한다  
  작업들은 콜스택에 적재되어 후입선출(LIFO) 방식으로 처리되는데 시간이 필요한 작업은 Web API로 넘기고 다음 작업을 처리한다  
  Web API에서 작업을 처리하고 결과를 태스크큐에 넣어주고 이는 선입선출`FIFO`방식으로 처리되며 처리시기는 이벤트루프가 결정한다  
  콜 스택의 작업이 끝나고 비었을 때 이벤트루프에 의해 태스크큐의 첫번째 태스크가 콜 스택으로 들어가고 콜 스택은 이 작업을 처리한다   
</details>

<details>
<summary>10-1. MacroTaskQueue & MicroTaskQueue</summary>  
<br>  
	
태스크큐는 구체적으로 매크로태스크큐와 마이크로태스크큐로 나뉘는데  
이는 어떤 함수를 사용하냐에 따라 달라진다  
콜백함수를 매크로태스크큐에 넣는 대표적인 함수는 setTimeout, setInterval이 있고,   
마이크로태스크큐에 넣는 대표적인 함수는 Promise가 있다  
이벤트 루프는 마이크로태스크를 먼저 처리하고 매크로태스크를 처리한다  
만약 이벤트 루프를 막을 우려가 있는 무거운 연산은 WebWorker를 통해 처리하도록 한다  

[Web Worker 사용경험](https://coqoa.tistory.com/118)  
</details>

<details>  
<summary>11. Execution Context - 실행 문맥</summary>
<br>  
	
  실행문맥은 코드를 실행하기 위한 조건이나 상태를 모아놓은 객체다  
  처음 자바스크립트 코드를 실행하면 콜 스택에 **전역 컨텍스트**가 생성되고 이는 종료시 사라진다  
  이후에 함수를 호출하면 콜 스택에 **함수 컨텍스트**를 적재하고 콜스택은 이를 후입선출(LIFO)방식으로 처리하며 함수 호출 완료시 함수컨텍스트는 사라진다  
  실행문맥은 Scope를 참조하고 Lexical환경을 통해 호이스팅, 클로저 기능을 사용한다  
</details>

---

### 12. Scope
  <details>  
  <summary></summary>
  
  Scope는 변수의 유효범위를 뜻한다  
  전역 스코프와 지역 스코프 로 나뉘는데 전역 스코프에 선언된 변수는 전역 변수라 하고 어느 곳에서든 해당 변수에 접근할 수 있다  
  지역 스코프에 선언된 변수는 지역 변수라 하고 해당 지역과 하위지역에서만 접근할 수 있다  
  
  자바스크립트는 기본적으로 함수 레벨 스코프를 따르기 때문에 var 키워드를 이용했을 때 함수 내부에서 선언시 지역스코프에 할당되고 그 외에는 전역 스코프에 할당된다  
  이후에 ES6에서 추가된 let과 const는 블록 레벨 스코프를 따르는데 이는 선언 위치에 따라 스코프를 할당한다  
  
  ```
  * 함수 레벨 스코프 : 함수 내부를 제외한 곳에서 선언하면 Global Scope 할당, 함수 내부는 Local Scope  
  * 블럭 레벨 스코프 : 선언한 위치에 따라 Scope 할당  
  ```
  
  </details>

---

### 13. Closure
  <details>  
  <summary></summary>
  
  클로저에 대한 MDN의 설명은 '함수와 함수가 선언된 Lexical환경의 조합' 이라고 한다.  
  실행 문맥의 Lexical환경에는 `Environment Record(환경레코드)`와 `Outer Environment Reference (외부환경 레퍼런스)`가 있다.  
  이 중 `외부환경 레퍼런스`는 외부 Lexical환경을 참조하는 포인터다  
  이 포인터는 스코프 중첩 구조에서 스코프 탐색을 위해 사용한다  
  즉, 클로저는 내부 함수에서 외부함수로 접근할 수 있는 기능을 제공해서 효율적인 식별자 결정을 가능케 하는 수단이다.  
  
  </details>

---
### 14. Hoisting
  <details>  
  <summary></summary>
  
  호이스팅은 선언문이 유효범위의 최상단으로 끌어올려지는듯한 현상을 말한다  
  자바스크립트는 함수를 실행하기 전 전체코드를 스캔해서 얻은 '변수와 같은 정보'를 환경 레코드에 기록해둔다  
  환경 레코드는 실행 문맥의 Lexical 환경에 존재하는 '식별자와 식별자에 바인딩 된 값'을 기록해둔 객체이다  
  호이스팅은 변수 호이스팅과 함수 호이스팅으로 나뉜다  
  
### 변수 호이스팅  

  #### var  
호이스팅 되면서 초기화 된다. 선언문 라인 이전에 접근 시 undefined를 반환한다  
  #### let, const
호이스팅은 되지만 초기화는 각각 선언문 라인에서 이뤄진다.  
선언문 라인 이전까지의 영역을 TDZ라 하고 이 TDZ에서 접근시 Reference Error를 반환한다
  * TDZ (Temporal Dead Zone) - 호이스팅 된 후부터 선언라인 이전까지 접근할 수 없는 영역 (일시적 사각지대)  
	  
### 함수 호이스팅
#### 함수 표현식  
변수에 할당하기 때문에 변수 호이스팅과 동일하게 동작한다  
#### 함수 선언식  
함수 선언과 동시에 환경 레코드에 완성된 함수 객체를 기록하기 때문에 선언문 라인 이전에도 사용할 수 있다  
  
  </details>

---
### 15. var, let, const
  <details>  
  <summary></summary>
  
  - var : 재선언 / 재할당 가능, 함수 레벨 스코프
  - let : 재선언 불가능, 재할당 가능, 블럭 레벨 스코프
  - const : 재선언 불가능, 재할당 불가능, 블럭 레벨 스코프
  
  - #### var를 안 쓰는 이유?
  	- 함수 레벨 스코프를 따르기 때문에 의도치 않게 전역 변수를 사용할 수 있고,  
	  재선언이 되기 때문에 여기저기서 변수의 중복이 발생할 수 있다  
	  이런 단점들로 인해 가독성이 떨어지고 유지보수가 힘들어지는건 물로 성능 하락에도 영향을 줄 수 있으므로 사용을 지양해야 한다
  
  </details>

---  

### 16. 브라우저 저장소
  <details>
  <summary></summary>
  HTTP는 요청에 대한 응답을 보내고 접속을 끊고 `비연결성(connectionless)`  
  상태 정보를 저장하지 않는 `무상태성(stateless)` 특징이 있다
  이런 특징덕분에 자원 낭비가 줄지만 매번 통신을 할 때마다 새로 연결해줘야하는 단점이 있기 때문에  
  쿠키와 웹스토리지 같은 브라우저 저장소를 사용한다  
  
#### 쿠키  

- 만료 기한이 있는 `키-밸류` 형태의 작은 데이터 파일로 HTTP요청과 응답 시 HTTP헤더에 담겨서 전송된다 
- 만료일을 지정한 쿠키를 `영구쿠키`라 하고 이는 브라우저를 닫아도 삭제되지 않는다   
- 만료일을 지정하지 않은 쿠키를 `세션쿠키`라 하고 이는 브라우저를 닫으면 삭제된다  
- 쿠키는 `저장 용량이 작고` `보안에 취약`하며 매번 서버에 전송되기 때문에 `네트워크 리소스가 낭비되고 불필요한 트래픽이 발생할 수 있다`는 단점이 있다  

- 클라이언트에서 HTTP요청시 서버는 HTTP헤더에서 쿠키를 확인하고 없다면 생성,  
  있으면 변경된 상태 정보를 수정한 뒤 HTTP헤더에 담아서 응답한다   

#### 세션  

- 세션은 쿠키를 기반으로 하지만 사용자 정보를 `서버`에 저장/관리한다
- 클라이언트 요청시 서버의 세션DB에 리소스를 생성하고 `세션ID를 발급`한 뒤 쿠키에 포함해서 응답한다
- 이후부터는 요청시 받은 쿠키에서 세션ID를 확인해서 세션DB의 데이터를 응답한다
- 즉, 쿠키를 `세션ID 전달 매개체`로만 사용해서 되어 쿠키에 비해 보안성이 좋아졌다  
- 하지만 이 역시 보안에 취약하므로 민감한 데이터는 서버측에서 `암호화`하는 과정이 필요하다
- 또, 세션이 늘어날 수록 서버에 차지하는 비중이 늘어나고 `서버 과부하의 원인`이 될 수 있다

#### 웹스토리지  
- 쿠키와 유사하지만 쿠키의 단점을 일부 개선했다
	- 5MB의 비교적 큰 저장 용량
	- 요청마다 서버로 전송하지 않음
	- `객체` 정보 저장 가능 
- 지속성에 따라 `로컬 스토리지`와 `세션스토리지`로 구분
	- 로컬스토리지 : 브라우저에 반영구적으로 저장되어 된다
	- 세션스토리지 : 세션 단위로 저장되고 브라우저 탭이나 창을 닫으면 데이터가 사라진다
  </details>

---
### 17. Iterable, Iterator, Generator
<details>
<summary></summary>

#### Iterable 
Iterable은 `순회 가능한 자료구조`로 for..of문을 순회하거나 Spread문법의 대상으로 이용할 수 있다.  
이터러블은 Symbol.Iterator라는 메서드를 소유하고 이 메서드는 `Iterator`를 반환한다

#### Iterator
`next()`메소드를 통해 이터러블 요소를 탐색하고 `IteratorResult객체`를 반환한다  
`IteratorResult객체`는 `value`와 `done` 2가지의 property를 가지고 있는데,  
`value`는 '최근 순회 요소', `done`은 '순회 완료 여부에 따른 boolean값'을 반환한다  

```
배열과 이터레이터의 차이점

  배열은 Random Access가 가능하지만 이터레이터는  
  next메서드를 사용하는 순차적인 접근만 지원한다
  
  배열은 더 기능이 많고 무거우며 이터레이터로 변환이 가능하지만 
  모든 요소를 메모리에 올리기 때문에 이는 자원 낭비가 될 수도 있다
  
  반면에 이터레이터는 비교적 기능이 간단하고 가볍다
  사용할 변수만 메모리에 올리면 되기 때문에 자원을 효율적으로 사용할 수 있다 
  때문에 일정한 규칙이 존재하는 수열과 같은 데이터를 다루는 작업에 적합하다 
```
#### Generator

함수의 실행을 멈췄다가 재개할 수 있는 기능을 가진 `Iterator`  
- function에 `*`을 붙여서 함수를 만들고 내부에 `yield` 키워드를 사용해서 함수의 실행을 멈출 위치를 지정한다  
- `next()`메서드를 호출하면 다음 `yield`까지 진행후 멈춘다  
- next 메소드를 호출하면`함수.next()` value와 done property를 반환하는데 value는 `yield의 값`을, done은 `boolean값`을 반환한다(실행이 끝나면 true)
- next()메소드 이외에도 return(), throw() 메소드를 사용할 수 있다 
	- `return('값')`  
		value의 값으로 yield대신 작성한 값을 반환하고 제너레이터를 종료시킨다   
		주의사항 : done이 true가 되면 value는 undefined가 된다 
    - `throw()`  
	제너레이터의 실행을 재개시키고 제너레이터 함수의 실행 문맥 속에 error를 넣는다
</details>

---
	
### 18. 프로그램이 할당받는 메모리 4영역
<details>
<summary></summary>

##### Text  
실행할 프로그램의 코드가 저장되는 코드영역

##### Data  
전역변수, 정적변수가 저장되는 영역  
메인 함수 전에 선언되어 프로그램이 끝날 때 까지 메모리에 남있음

##### Heap  
사용자에 의해 관리되는 동적 할당 변수들이 저장되는 영역  
메모리의 낮은 주소에서 높은 주소로 할당된다

##### Stack  
함수의 호출과 관계되는 지역변수, 매개변수가 저장되는 영역    
함수의 호출과 함께 할당되고 호출 완료시 소멸된다  
메모리의 높은 주소에서 낮은 주소 방향으로 할당된다  

</details>
	
---
	
### 19. 메모리 계층도
  <details>   
  <summary></summary>
 메모리 계층은 크게 레지스터 - 캐시 - 주기억장치 - 보조기억장치로 나뉜다
##### 레지스터와 캐시는 CPU 내부에, 메모리는 CPU 외부에 존재한다.
- 레지스터  
  프로세서에 위치한 소량의 데이터나 처리중인 중간 결과 값과 같이 프로세스가 바로 사용할 수 있는 데이터를 담고 있는 영역
  
- 캐시  
시간적, 공간적 지역성을 기반으로 가장 중요하고 자주 접근될 것 같은 데이터를 보관하는 영역
CPU와 메모리 간 속도차이로 발생하는 성능 저하를 막는 역할을 하고  
캐시메모리는 CPU뿐 아니라 메모리, ssd, hdd, 파일시스템, 브라우저 등등 다양하게 사용된다

- 메모리  
  CPU 외부에 존재하지만 CPU에서 직접 접근이 가능한 메모리로 cpu의 처리  결과, 현재 필요한 데이터, 가까운 미래에 필요할 것 같은 데이터를 준비하는 용도로 사용한다
  휘발성 메모리 RAM과 비휘발성 메모리 ROM이 있다
  
- 디스크
  CPU에서 직접 접근이 불가능한 영역  
  데이터를 캐시 또는 메모리로 이동시키고 cpu는 캐시 또는 메모리에 접근해서 작업할 데이터를 받는다
  
  </details>

---

### 20. 자바스크립트에서 this란?
  <details>    
  <summary></summary>
  
  this는 호출하는 위치에 따라 다른 값을 반환하는 '자기 참조 변수'다  
  1. 일반 함수 : 전역에 선언된 일반 함수는 window객체의 메소드이므로 window를 가리킴
  2. 화살표 함수 : 외부 함수의 this
  3. 생성자 함수 : new를 통해 생성된 객체
  4. 객체의 메서드 : 메서드 자신을 호출한 객체
  5. addEventListener : HTML요소
  6. strict모드 : undefined
  
  명시적 바인딩을 위해 apply, call, bind 메소드를 사용한다
  - apply와 call은 첫 번째 인자로 this를 바인딩 한다
  - apply : 두 번째 인자로 parameter를 받는다
  - call : 두 번째 인자로 배열을 받는다.
  - bind : 새로운 함수를 만들어 리턴해주기 때문에 새로운 변수에 담아서 실행해야한다
  
  </details>

---

### 21. Arrow Function
  <details>    
  <summary></summary>
  
function키워드 대신 화살표를 사용해서 보다 간략한 방법으로 함수를 선언할 수 있다.  
익명 함수로만 사용할 수 있기 때문에 호출을 위해선 함수 표현식을 사용하고 콜백 함수로 사용할 수도 있다.  
일반 함수와 화살표 함수는 this의 차이 때문에 주의해서 사용해야한다.  

1. this에 바인딩할 객체가 정적으로 결정되는데 이를 Lexical Scope라 하고 외부 스코프의 this를 가리킨다  
(일반 함수는 바인딩할 객체가 호출 함수에 따라 동적으로 결정된다)  

2. 생성자 함수에 사용할 수 없다

3. 메소드에 사용하면 상위 스코프인 window를 가리키므로 사용하면 안된다  
(일반 함수는 메소드를 호출하는 객체 자신을 가리킨다) 

4. addEventListener에 사용하면 상위 컨텍스트인 전역 객체 window를 가리킨다  
(일반 함수는 HTML요소를 가리킴)

5. apply, call, bind등 명시적 바인딩을 위한 메소드를 사용하지 못한다

  </details>

---

### 22. Race Condition  
<details>  
<summary></summary>

둘 이상의 프로세스가 공유변수에 동시접근해서 실행 순서에 따라 결과가 달라지는 현상으로  
세가지 조건을 만족하면 Race Condition을 해결할 수 있다.   

- 하나의 자원에는 하나의 프로세스만 접근할 수 있도록 한다.  
- 임계 영역이 비었을 때 프로세스가 진입할 수 있도록 해서 교착 상태를 예방한다.
- 프로세스의 임계영역 진입 요청이 있으면 무한정 대기하지 않도록  
다른 프로세스의 진입 횟수에 제한을 줘서 기아 상태를 예방한다.

</details>

---

### 23. Deadlock
<details>
<summary></summary>

둘 이상의 작업이 자원을 점유하며 상대방의 작업이 끝나기만을 기다리며 자신의 작업을 수행하지 못하는 상태  

- 하나의 프로세스가 임계영역에서 작업중일 때 다른 프로세스는 진입할 수 없도록 하는 `상호배제조건`
- 프로세스가 자원을 점유한 상태로 자원을 기다리는 `점유대기 조건`
- 할당받은 자원을 스스로 반납하지 않는 한 뺏기지 않는 `비선점 조건`
- 자원을 요청하는 프로세스와 할당받은 프로세스간 순환이 발생하는 `순환대기 조건`  

이 4가지 조건을 만족할 때 `교착상태`가 발생할 수 있다.

이런 교착상태를 해결하기 위해선 `예방, 회피, 탐지 및 회복, 무시` 4가지 방법이 있다
- `예방`은 교착상태가 발생하기 전 4가지 조건중 하나를 제거하는 방법으로 자원 낭비가 가장 심하다
- `회피`는 프로세스가 자원을 요구하면 자원 할당 후에도 안정상태로 남는지 미리 확인하는 방법이다
- `탐지 및 회복`은 말그대로 문제 발생시 탐지 후 회복하는 방법으로 관련 프로세스를 하나씩 혹은 모두 중지시키거나 자원을 빼앗는 방법이다  

현대의 운영체제는 위의 방법들이 많은 오버헤드를 발생시키기 때문에 교착상태를 무시하는 행동을 취한다
- `무시` 방법을 통해 교착상태가 발생하면 프로세스가 느려지는 이상반응이 생기기 때문에 사용자가 해당 프로세스를 직접 종료시킨다

</details>

---
---
---
## 리액트 관련 질문

### 24. React ?
<details>
<summary></summary>

리액트는 Single Page Application의 UI를 생성하는데 집중한 자바스크립트 라이브러리이다  
1. Single Page Application의 특징을 가짐
2. JSX를 사용  
3. 단방향 데이터바인딩 지원  
4. 가상 DOM을 이용한 퍼포먼스 최적화  
5. 컴포넌트 기반 프로그래밍 등의 특징이 있다
6. 리액트네이티브를 익히면 웹과 앱 모두 대응이 가능하다

</details>

---
### 25. SPA & MPA / CSR & SSR
<details>
<summary></summary>

<b>SPA</b>는 Single Page Application의 약자로 <b>CSR</b> (Client Side Rendering)방식으로 렌더링한다.  
Client Side Rendering은 서버로부터 빈 뼈대 HTML파일을 받은 뒤 `<script>`태그에 정의된 자바스크립트 코드를 통해  
동적으로 DOM을 생성하고 렌더링한다  
클라이언트에서 작업을 처리하기 때문에 `서버의 부담`이 줄어들고,  
`깜빡임 이슈`가 없어 사용자 경험이 좋아지고,  
새로운 요청이 있으면 `변경해야할 부분만 갱신`하기 때문에 구동속도가 빨라지고,  
자바스크립트를 통해 동적으로 DOM을 생성하기 때문에 TTV와 TTI의 간극이 없다는 <b>장점</b>이 있지만  
리소스를 한번에 받기 때문에 초기 구동이 오래걸리고,  
검색 엔진 최적화`(SEO - Search Engine Optimization)`에 좋지 않다는 <b>단점</b>이 있다

<b>MPA</b>는 Multi Page Application의 약자로 <b>SSR</b> (Server Side Rendering)방식으로 렌더링한다.  
SSR은 전통적인 웹의 형태인데  
초기 로딩이 빠르고 검색 엔진 최적화에 유리하다는 <b>장점</b>이 있지만  
깜빡임 이슈가 있고,  
서버측에서 연산을 수행하기 때문에 서버 과부하가 될 수 있으며,  
HTML렌더를 통해 View는 가능하지만 자바스크립트 로직을 연결해야 Interaction이 가능하기 때문에  
TTV와 TTI간에 공백기간이 존재한다는 <b>단점</b>이 있다  

</details>

---
### 26. JSX
<details>
<summary></summary>
  
JSX는 HTML 확장언어로 HTML에서 자바스크립트 변수를 바로 사용할 수 있는 템플릿언어다. 
JSX를 통해 데이터 바인딩이 쉬워진다. JSXsms HTML의 확장 언어기 때문에 익히기 쉽다는 장점도 있다.
</details>

---
### 27. 양방향 데이터 바인딩 & 단방향 데이터 바인딩
<details>
<summary></summary>
  
- 양방향 데이터 바인딩   
UI를 감지하는 watcher와 데이터 변경을 감지하는 watcher가 UI와 데이터를 동기화 시켜주는 방식으로  
코드가 간결해지는 장점이 있지만 변화에 따라 DOM객체 전체를 렌더링해서 데이터를 바꿔주므로 성능이 감소하는 경우가 있다  

- 단방향 데이터 바인딩  
하나의 watcher가 데이터 변경을 감지하면 UI를 갱신하고 UI가 데이터를 갱신하려면 이벤트를 통해서 갱신할 수 있는 방식으로  
데이터 갱신에 따른 성능변화가 없고,  
코드 흐름이 단순해져 이해하기 쉬워지고,  
데이터 추적과 디버깅이 쉬워진다는 장점이 있으나,  
코드가 길어진다는 단점이 있다
</details>

---
### 28. 가상DOM (Virtual DOM)
	
<details>
<summary></summary>
	
가상돔은 DOM을 추상화 시킨 객체다  
렌더링은 상황에 따라 반복이 될 수 있고 성능을 많이 잡아먹는다  
직접 DOM을 조작할 경우 리렌더링`(reflow 및 repaint)`이 발생하기 때문에  
성능이 저하되고 깜빡임 이슈가 생겨서 사용성이 안좋아진다.  
이런 단점을 해결하기 위해 가상DOM을 사용하는데 변경사항 발생시 가상DOM에서 연산을 수행하고  
이전 가상DOM과 현재 가상DOM을 비교 후 실제 DOM을 갱신한다.  
가상DOM을 통해 깜빡임 이슈를 해결할 수 있고 리렌더링을 최소화해서 성능 개선도 할 수 있다.  
```
DOM이 추가혹은 삭제될때, 기하학적 변화가 있을때는 reflow가 발생하고  
기하학적 변화 없이 CSS가 변경되는 상황에는 repaint가 발생한다  
```
</details>

---

### 25. React Hook
		
<details>
<summary></summary>
	
- useState  
상태 관리를 위한 Hook으로 
상태 값 갱신 함수 변경을 통해 스크린 렌더링 없이 상태 값을 변경하는 기능
- useEffect  
컴포넌트가 렌더링 될 때마다 특정 작업을 수행하는 Hook으로  
배열로 받는 두 번째 인자를 통해 처리 시기를 결정할 수 있다  
배열을 생략하면 리렌더링 될 때마다 실행하고, 빈 배열을 넣으면 최초 렌더링시에만 실행하며,  
state값을 넣은 배열은 해당 state가 변경될 때 마다 실행한다
- useRef  
특정 DOM을 선택할 때 혹은 리렌더링이 되도 값을 유지하고 싶을 때 사용하는 Hook으로  
모바일 키보드의 done버튼을 통해 다음 입력창으로 넘어가기위해서, 애니메이션이나 랜덤 숫자 할당을 할 때 값을 유지하기 위해서 사용해본 경험이 있다.
	
</details>

---

	
	
