### 1. Process와 Thread의 차이
  <details>  
  <summary></summary>
  
  프로세스는 운영체제로부터 **자원을 할당**받는 '작업'의 단위고  
  스레드는 프로세스가 할당받은 **자원을 사용**하는 '실행'의 단위다  
  
  프로세스는 **독립적으로** 메모리 공간을 할당받기 때문에 프로세스간 자원을 공유하지도 않고 영향을 끼치지도 않는다  
  하지만 잦은 컨텍스트 스위칭으로 인해 **비용이 발생**한다는 점과  
  프로세스간 통신을 위해선 IPC라는 특수한 통신 기법을 사용해야한다는 단점이 있다 
  
  
  스레드는 메모리의 **Stack영역을 각각 할당**받고 Code, Data, Heap영역은 서로 공유한다.  
  컨텍스트 스위칭이 감소하면서 자원을 할당하는 시스템 콜이 줄어들어 **시스템 자원 소모가 줄고**,  
  공유자원을 통한 **처리비용 감소 및 처리량 증가** 등의 장점이 있지만,  
  **자원 공유로 인한 Race Condition Issue 등의 문제**가 발생할 수 있고,  
  하나의 스레드에서 발생한 문제가 다른 이웃 스레드에도 **영향을 끼칠 수 있다**는 단점이 있다
  
    
    
  </details>

---
### 2. Race Condition
  <details>  
  <summary></summary>
  
    
  </details>

---

### 3. 메모리의 역할
  <details>  
  <summary></summary>
  
  메모리는 대표적으로 RAM과 ROM으로 구분할 수 있다  
  RAM은 Random Access Memory의 줄임말로 이름에서 알 수 있듯이  
  임의의 영역에 접근하여 읽기 / 쓰기를 할 수 있는 휘발성 메모리이며 어느 위치의 데이터에 접근하든 동일한 시간이 걸린다는 특징이 있다   
  CPU의 처리에 의한 결과나 처리해야 할 데이터를 준비하는 용도로 사용한다
  
  ROM은 Read Only Memory의 약자로 읽기만 가능한 비휘발성 메모리이다  
  변경 가능성이 없는 시스템 소프트웨어를 저장하는데 주로 사용하고  
  삭제나 수정을 위해선 특수한 방법을 사용해야한다.
  
  </details>

---

### 4. 비동기 프로그래밍이란
  <details>  
  <summary></summary>
  
  비동기 프로그래밍은 시간일 걸리는 작업이 끝나지 않은 상태에서 다음 작업을 요청하여 non-block방식으로 처리하는 프로그래밍 기법이다
  Callback함수, Promise, await / async를 통해 구현할 수 있다
  

  **Callback함수**는 함수의 인자로 들어가는 함수를 말하며 어떤 함수를 사용하냐에 따라 동기적 / 비동기적으로 선택해서 구현할 수 있다
  간편하지만 중첩이 과해지면 가독성도 안좋고 유지보수도 힘들어지는 Callback지옥을 만날 수 있다
  
  **Promise**는 비동기 작업의 결과에 따라 표준화된 방식으로 처리한다  
  resolve와 reject라는 인자를 받고 성공시 then을 통해 resolve를, 실패시 catch를 통해 reject를, finally를 통해 성공 / 실패에 상관없는 결과값을 호출할 수 있다  
  promise를 반환하기 때문에 promise chaining이 가능하지만 이 역시 중첩이 과하면 Callback지옥과 유사한 경험을 할 수 있다  
  
  **async / await**을 통해 비동기를 동기적으로 보이게 해서 Promise를 단순화할 수 있다  
  async 함수 내부에서 await 사용을 통해 구현할 수 있고 예외처리는 try/catch문으로 한다  
  promise를 반환하기 때문에 await, then 등을 붙일 수 있고 사용법에 따라 동기적 / 비동기적으로 처리할 수 있다
  
  </details>

---
### 5. 자료구조란?
  <details>    
  <summary></summary>
  
  자료구조는 데이터를 효율적으로 사용하기위해 체계적으로 저장하기 위한 방식으로  
  정수, 실수 같은 자료형을 나타내는 단순 구조,  
  배열, 연결리스트, 스택, 큐 등등의 선형 구조,  
  그래프, 트리같은 비선형 구조,  
  그리고 파일구조가 있다  
  
  **배열** : 가장 기본적인 자료구조로 동일한 타입의 데이터가 연속적으로 있고 Index를 통해 접근할 수 있다  
  **연결 리스트** : 데이터와 포인터로 이루어진 노드들이 연결되어 리스트를 이루는 자료 구조로 단일 연결리스트, 이중 연결 리스트, 원형 연결 리스트가 있다  
  **스택** : LIFO 방식으로 동작하는 자료 구조  
  **큐** : FIFO 방식으로 동작하는 자료 구조  
  
  **트리** : root노드로 부터 뻗어나오는 child노드로 이뤄진 계층적 자료구조  
  **그래프** : 노드와 간선을 하나로 모은 자료구조로 객체간의 관계 표현이 가능하다, 무방향 그래프와 방향 그래프로 나뉜다
  </details>

---

### 7. 함수와 메소드의 차이
  <details>    
  <summary></summary>
  
  함수는 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드의 집합이다
  메소드는 클래스내부에 정의된 함수를 뜻한다
  </details>

---
### 8. REST API란  
  <details>  
  <summary></summary>
  
  REST는 'REpresentational State Transfer'의 약자로 직역하자면 "표현적인 상태 전달"이고 API는 소프트웨어간 지정된 방식으로 통신하기 위한 수단이다  
  즉 '표현적인 상태 전달을 통해 소프트웨어간 통신하는것'이 REST스러운 API라 할 수 있고 이는 HTTP프로토콜을 HTTP프로토콜답게 사용하기 위한 수단이라고 볼 수 있다   
  CRUD같은 행위를 표현하기 위한 'HTTP Method'와 리소스 식별을 위한 'URI'의 조합을 통해 응답코드를 받을 수 있다
  - HTTP Method는 POST, GET, PUT/PATCH, DELETE가 있다
      - POST : 리소스 생성
      - GET : 리소스 요청
      - PUT : 전체 업데이트
      - PATCH : 부분 업데이트
      - DELETE : 삭제

  - GET과 POST의 차이
      - GET은 리소스 요청을 위해 사용한다  
  캐쉬될 수 있고 브라우저 기록이 남으며 북마크로 추가도 가능하다  
  데이터 길이에 제한이 있고 쿼리 스트링 방식으로 전달되며 응답코드로 200(ok)을 받는다

      - POST는 리소스 생성이나 업데이트를 위해 사용한다  
  GET과는 반대로 캐시될수 없고 브라우저 기록도 안남으면 북마크 추가도 불가능하다  
  데이터 길이에 제한이 없고 HTTP BODY에 담겨 전달되고 응답코드는 201(create)을 받는다

  </details>
  
---

### 9. 브라우저 동작 원리
  <details>  
  <summary></summary>
  
  브라우저는 요청을 통해 서버로부터 HTML파일을 먼저 받아온다  
  렌더링 엔진이 HTML파서를 통해 파싱해서 **DOM트리**를 만든다
  `<link>`태그를 통해 StyleSheet를 받으면 렌더링 엔진의 CSS파서가 파싱해서 **CSSOM트리**를 만든다  
  DOM트리와 CSSOM트리를 합쳐 **렌더 트리**를 만들고 렌더링한다
  
  HTML파싱중에 `<script>`태그를 만나면 HTML파서는 파싱을 중지하고 JS엔진으로 제어권을 넘긴다  
  JS엔진은 `<script>`태그 내부의 코드나 src attribute에 정의된 JS코드를 로드, 파싱, 컴파일 하는 과정을 거친 후 HTML파서로 제어권을 넘긴다
  
  위에서 설명했듯이 HTML파싱중 `<script>`태그를 만나면 파싱을 멈추기 때문에 `<script>`태그를 `<body>`태그 최하단에 배치하거나 async 또는 defer같은 속성을 사용하도록 해야 한다
  
  </details>

---

### 10. 자바스크립트의 동작 원리
  <details>  
  <summary></summary>
  	  
  자바스크립트는 싱글스레드 언어지만 Web API를 통해 비동기 작업을 처리한다  
  작업들은 콜스택에 적재되어 LIFO 방식으로 처리되는데 시간이 필요한 작업은 Web API로 넘기고 다음 작업을 처리한다  
  Web API에서 작업을 처리하고 결과를 태스크큐에 넣어주고 이는 FIFO방식으로 처리되며 처리시기는 이벤트루프가 결정한다  
  콜 스택의 작업이 끝나고 비었을 때 이벤트루프에 의해 태스크큐의 첫번째 태스크가 콜 스택으로 들어가고 콜 스택은 이 작업을 처리한다   
  
  </details>

---

### 10-1. EventLoop - MacroTaskQueue & MicroTaskQueue
<details>
<summary></summary>  

이벤트 루프는 콜 스택과 태스크큐를 감시하다가 콜스택이 비어있을 경우에  
태스크큐의 태스크를 가져와서 콜스택에 넣어 처리하도록 해주는 기능을 한다  
태스크큐는 구체적으로 매크로태스크큐와 마이크로태스크큐로 나뉘는데  
이는 어떤 함수를 실행하냐에 따라 달라진다  
콜백함수를 매크로태스크큐에 넣는 대표적인 함수는 setInterval이 있고,   
마이크로태스크큐에 넣는 대표적인 함수는 Promise가 있다  
이벤트 루프는 마이크로태스크를 먼저 처리하고 매크로태스크를 처리한다  
만약 이벤트 루프를 막을 우려가 있는 무거운 연산은 WebWorker를 통해 처리하도록 한다  
  
[Web Worker 사용경험](https://coqoa.tistory.com/118)  
	
</details>

---

### 11. Execution Context - 실행 문맥
  <details>  
  <summary></summary>
  
  실행문맥은 코드를 실행하기 위한 조건이나 상태를 모아놓은 객체다  
  처음 자바스크립트 코드를 실행하면 콜 스택에 **전역 컨텍스트**가 생성되고 이는 종료시 사라진다  
  이후에 함수를 호출하면 콜 스택에 **함수 컨텍스트**를 적재하고 콜스택은 이를 LIFO방식으로 처리하며 함수 호출 완료시 함수컨텍스트는 사라진다  
  실행문맥은 Scope를 참조하고 Lexical환경을 통해 호이스팅, 클로저 기능을 사용한다  
  
  </details>

---

### 12. Scope
  <details>  
  <summary></summary>
  
  Scope는 변수의 유효범위를 뜻한다  
  전역 스코프와 지역 스코프 로 나뉘는데 전역 스코프에 선언된 변수는 전역 변수라 하고 어느 곳에서든 해당 변수에 접근할 수 있다  
  지역 스코프에 선언된 변수는 지역 변수라 하고 해당 지역과 하위지역에서만 접근할 수 있다  
  
  자바스크립트는 기본적으로 함수 레벨 스코프를 따르기 때문에 var 키워드를 이용했을 때 함수 내부에서 선언시 지역스코프에 할당되고 그 외에는 전역 스코프에 할당된다  
  이후에 ES6에서 추가된 let과 const는 블록 레벨 스코프를 따르는데 이는 선언 위치에 따라 스코프를 할당한다  
  
  ```
  * 함수 레벨 스코프 : 함수 내부를 제외한 곳에서 선언하면 Global scope 할당, 함수 내부는 Local Scope  
  * 블럭 레벨 스코프 : 선언한 위치에 따라 scope 할당  
  ```
  
  </details>

---

### 13. Closure
  <details>  
  <summary></summary>
  
  클로저에 대한 MDN의 설명은 '함수와 함수가 선언된 Lexical환경의 조합' 이라고 한다.  
  실행 문맥의 Lexical환경에는 `Environment Record(환경레코드)`와 `Outer Environment Reference (외부 환경 참조)`가 있다.  
  이 중 `Outer`는 외부 Lexical환경을 참조하는 포인터로 스코프 중첩 구조에서 스코프 탐색을 위해 사용한다  
  즉, 클로저는 함수와 Lexical환경의 조합을 통해 내부 함수에서 외부함수로 접근할 수 있는 기능을 제공해서 효율적인 식별자 결정을 가능케 하는 수단이다.  
  
  </details>

---
### 14. Hoisting
  <details>  
  <summary></summary>
  
  호이스팅은 선언문이 유효범위의 최상단으로 끌어올려지는듯한 현상을 말한다  
  자바스크립트는 함수를 실행하기 전 전체코드를 스캔해서 얻은 '변수와 같은 정보'를 환경레코드에 기록해둔다  
  환경 레코드는 실행 문맥의 Lexical 환경에 존재하는 '식별자와 식별자에 바인딩 된 값'을 기록해둔 객체이다  
  호이스팅은 변수 호이스팅과 함수 호이스팅으로 나뉜다  
  
### 변수 호이스팅  

  #### var  
호이스팅 되면서 초기화 된다. 선언문 라인 이전에 접근 시 undefined를 반환한다  
  #### let, const
호이스팅은 되지만 초기화는 각각 선언문 라인에서 이뤄진다.  
선언문 라인 이전까지의 영역을 TDZ라 하고 이 TDZ에서 접근시 Reference Error를 반환한다
  * TDZ (Temporal Dead Zone) - 호이스팅 된 후부터 선언라인 이전까지 접근할 수 없는 영역 (일시적 사각지대)  
	  
### 함수 호이스팅
#### 함수 표현식  
변수에 할당하기 때문에 변수 호이스팅과 동일하게 동작한다  
#### 함수 선언식  
함수 선언과 동시에 환경 레코드에 완성된 함수 객체를 기록하기 때문에 선언문 라인 이전에도 사용할 수 있다  
  
  </details>

---
### 15. var, let, const
  <details>  
  <summary></summary>
  
  - var : 재선언 / 재할당 가능, 함수 스코프
  - let : 재선언 불가능, 재할당 가능, 블럭 스코프
  - const : 재선언 불가능, 재할당 불가능, 블럭스코프
  
  - #### var를 안 쓰는 이유?
  	- 함수 스코프 범위를 가지기 때문에 의도치 않게 전역 변수를 사용할 수 있고,  
	  재선언 및 재할당이 된다는 특징 때문에 여기저기서 변수의 중복이 발생할 수 있다  
	  이런 단점들로 인해 성능 하락은 물론 유지보수가 힘들어진다
  
  </details>

---  

### 16. 브라우저 저장소
  <details>
  <summary></summary>
  HTTP는 요청에 대한 응답을 보내고 접속을 끊는 `비연결성(connectionless)`이란 특징과  
  상태 정보를 저장하지 않는 `무상태성(stateless)`이란 특징이 있다
  
  이런 특징덕분에 자원 낭비가 줄어드는 장점이 있지만 매번 통신을 할 때마다 새로 연결해줘야하는 단점이 생기기 때문에  
  쿠키와 웹스토리지 같은 브라우저 저장소를 사용한다  
  
#### 쿠키  

- 만료 기한이 있는 `키-밸류` 형태의 작은 데이터 파일
- HTTP헤더에 담아서 요청 및 응답 한다  
- 클라이언트에서 HTTP요청시 서버는 HTTP헤더에서 쿠키를 확인하고 없다면 생성,  
  있으면 변경된 상태 정보를 수정한 뒤 HTTP헤더에 담아서 응답한다   
- 만료일을 지정한 쿠키를 `영구쿠키`라 하고 이는 브라우저를 닫아도 삭제되지 않는다   
- 만료일을 지정하지 않은 쿠키를 `세션쿠키`라 하고 이는 브라우저를 닫으면 삭제된다  
- 쿠키는 `저장 용량이 작고` `보안에 취약`하며 매번 서버에 전송되기 때문에 `불필요한 트래픽이 발생`한다는 단점이 있다  

#### 세션  

- 세션은 쿠키를 기반으로 하지만 사용자 정보를 `서버`에 저장/관리한다
- 클라이언트 요청시 서버의 세션DB에 리소스를 생성하고 `세션ID를 발급`한 뒤 쿠키에 포함해서 응답한다
- 이후부터는 요청시 받은 쿠키에서 세션ID를 확인해서 세션DB의 데이터를 응답한다
- 즉, 쿠키를 `세션ID 전달 매개체`로만 사용해서 되어 쿠키에 비해 보안성이 좋아졌다  
- 하지만 이 역시 보안에 취약하므로 민감한 데이터는 서버측에서 `암호화`하는 과정이 필요하다
- 또, 세션이 늘어날 수록 서버에 차지하는 비중이 늘어나고 `서버 과부하의 원인`이 될 수 있다

#### 웹스토리지  
- 쿠키와 유사하지만 쿠키의 단점을 일부 개선했다
	- 5MB의 비교적 큰 저장 용량
	- 요청마다 서버로 전송하지 않음
	- `객체` 정보 저장 가능 
- 지속성에 따라 `로컬 스토리지`와 `세션스토리지`로 구분
	- 로컬스토리지 : 브라우저에 반영구적으로 저장되어 된다
	- 세션스토리지 : 세션 단위로 저장되고 브라우저 탭이나 창을 닫으면 데이터가 사라진다
  </details>

---
### 17. Iterable, Iterator, Generator
<details>
<summary></summary>

#### Iterable 
Iterable은 `순회가 가능한 자료구조`로 for..of문을 순회하거나 Spread문법의 대상으로 이용할 수 있다.  
이터러블은 Symbol.Iterator라는 메서드를 소유하고 이 메서드는 `Iterator를 반환`한다

#### Iterator
`next()`메소드를 통해 이터러블 요소를 탐색하고 `IteratorResult객체`를 반환한다  
`IteratorResult객체`는 `value`와 `done` 2가지의 property를 가지고 있는데,  
`value`는 '최근 순회 요소', `done`은 '순회 완료 여부에 따른 boolean값'을 반환한다  

```
배열과 이터레이터의 차이점

  배열은 Random Access가 가능하지만 이터레이터는  
  next메서드를 사용하는 순차적인 접근만 지원한다
  
  배열은 더 기능이 많고 무거우며 이터레이터로 변환이 가능하지만 
  모든 요소를 메모리에 올리기 때문에 이는 자원 낭비가 될 수도 있다
  
  반면에 이터레이터는 비교적 기능이 간단하고 가볍다
  사용할 변수만 메모리에 올리면 되기 때문에 자원을 효율적으로 사용할 수 있다 
  때문에 일정한 규칙이 존재하는 수열과 같은 데이터를 다루는 작업에 적합하다 
```
#### Generator

함수의 실행을 멈췄다가 재개할 수 있는 기능을 가진 Iterator  
- function에 `*`을 붙여서 함수를 만들고 내부에 `yield` 키워드를 사용해서 함수의 실행을 멈출 위치를 지정한다  
- `next()`메서드를 호출하면 다음 `yield`까지 진행후 멈춘다  
  이 때 `next()`메서드는 `value`와 `done`을 반환하는데 value는 `yield의 값`을, done은 `boolean값`을 반환한다(실행이 끝나면 true)
- 제너레이터 객체의 netx 메소드를 호출하면(함수.next()) value와 done property를 반환한다
- next()메소드 이외에도 return(), throw() 메소드를 사용할 수 있다 
	- `return('값')`  
		value의 값으로 yield대신 작성한 값을 반환하고 제너레이터를 종료시킨다   
		주의사항 : done이 true가 되면 value는 undefined가 된다 
    - `throw()`  
	제너레이터의 실행을 재개시키고 제너레이터 함수의 실행 문맥 속에 error를 넣는다
</details>

---
	
### 18. 프로그램이 할당받는 메모리 4영역
<details>
<summary></summary>

##### Text  
실행할 프로그램의 코드가 저장되는 코드영역

##### Data  
전역변수, 정적변수가 저장되는 영역  
메인 함수 전에 선언되어 프로그램이 끝날 때 까지 메모리에 남있음

##### Heap  
사용자에 의해 관리되는 동적 할당 변수들이 저장되는 영역  
메모리의 낮은 주소에서 높은 주소로 할당된다

##### Stack  
함수의 호출과 관계되는 지역변수, 매개변수가 저장되는 영역    
함수의 호출과 함께 할당되고 호출 완료시 소멸된다  
메모리의 높은 주소에서 낮은 주소 방향으로 할당된다  

</details>
	
---
	
### 19. 메모리 계층도
  <details>   
  <summary></summary>
 
##### 컴퓨터 메모리는 용량, 스루풋, 레이턴시가 중요하다
- 스루풋(Throughput) : 단위 시간당 데이터 처리량
- 레이턴시(Latency) : 지연시간, 대기시간, 응답시간 등의 
  	  CPU 주소처리문제 또는 CPU와 메모리 간의 물리적 거리에 따른 문제
      
##### 레지스터와 캐시는 CPU 내부에, 메모리는 CPU 외부에 존재한다.
- 레지스터  
  프로세서에 위치한 고속메모리,  
  소량의 데이터나 처리중인 중간 결과 값과 같이 프로세스가 바로 사용할 수 있는 데이터를 담고 있는 영역
  
- 캐시  
  자주 사용되는 데이터를 복사해놓는 임시 저장소,  
CPU와 메모리 간의 접근 시간을 줄여 속도차이로 발생하는 성능 저하를 막는다

- 메모리  
  CPU 외부에 존재하지만 CPU에서 직접 접근이 가능한 메모리  
  휘발성 메모리 RAM과 비휘발성 메모리 ROM이 있다
  
- 디스크
  CPU에서 직접 접근이 불가능한 영역  
  디스크 데이터를 캐시 또는 메모리로 이동시키고 메모리에 접근한다
  
  </details>

---

### 20. 자바스크립트에서 this란?
  <details>    
  <summary></summary>
  
  this는 호출하는 위치에 따라 다른 값을 반환하는 '자기 참조 변수'다  
  일반적으로는 window 객체를 반환하지만 예외 사항이 있다
  1. 일반 함수 : 전역에 선언된 일반 함수는 window객체의 메소드이므로 window를 가리킴
  2. 화살표 함수 : 외부 함수의 this
  3. 생성자 함수 : new를 통해 생성된 객체
  4. 객체의 메서드 : 메서드 자신을 호출한 객체
  5. addEventListener : HTML요소
  6. strict모드 : undefined
  
  명시적 바인딩을 위해 apply, call, bind 메소드를 사용한다
  - apply와 call은 첫 번째 인자로 this를 바인딩 한다
  - apply : 두 번째 인자로 parameter를 받는다
  - call : 두 번째 인자로 배열을 받는다.
  - bind : 새로운 함수를 만들어 리턴해주기 때문에 새로운 변수에 담아서 실행해야한다
  
  </details>

---

### 21. Arrow Function
  <details>    
  <summary></summary>
  
function키워드 대신 화살표를 사용해서 보다 간략한 방법으로 함수를 선언할 수 있다.  
익명 함수로만 사용할 수 있기 때문에 호출을 위해선 함수 표현식을 사용하고 콜백 함수로 사용할 수도 있다.  
일반 함수와 화살표 함수는 this의 차이 때문에 주의해서 사용해야한다.  

1. this에 바인딩할 객체가 정적으로 결정되는데 이를 Lexical Scope라 하고 외부 스코프의 this를 가리킨다  
(일반 함수는 바인딩할 객체가 호출 함수에 따라 동적으로 결정된다)  

2. 생성자 함수에 사용할 수 없다

3. 메소드에 사용하면 상위 스코프인 window를 가리키므로 사용하면 안된다  
(일반 함수는 메소드를 호출하는 객체 자신을 가리킨다) 

4. addEventListener에 사용하면 상위 컨텍스트인 전역 객체 window를 가리킨다  
(일반 함수는 HTML요소를 가리킴)

5. apply, call, bind등 명시적 바인딩을 위한 메소드를 사용하지 못한다

  </details>

---
