CPU는 컴퓨터 시스템의 주요 자원을 보호하기 위해 유저 모드와 커널 모드 두 가지 모드를 제공한다

### User Mode  
- 프로그램이 일반적으로 실행되는 모드  
인터럽트 혹은 시스템 콜 발생시 커널모드로 전환된다

### Kernal Mode  
- 프로그램의 현재 CPU상태 정보를 저장하고 인터럽트나 시스템콜을 처리하는 모드  
처리 완료하면 중단됐던 프로그램의 CPU 상태 정보를 복원하고 통제권을 프로그램에게 반환한다

### Kernal   
- 운영체제의 핵심으로 컴퓨터 시스템을 관리, 감독하는 역할을 하고  
하드웨어 관련 작업을 수행한다

### 커널모드는 왜 존재하나?  
- 시스템의 전반적인 부분이나 하드웨어 관련 부분을 커널이 담당하고    
프로그램은 커널을 통해서만 컴퓨터 시스템이나 하드웨어를 사용할 수 있게 함으로써  
컴퓨터 시스템이 안정적으로 동작할 수 있는 환경을 제공할 수 있다  

### 인터럽트 Interrupt  
- 시스템에 발생한 다양한 종류의 이벤트 혹은 이벤트를 알리는 메커니즘으로   
CPU는 한번에 하나의 작업만 수행할 수 있기 때문에 우선 순위가 급한 작업을 처리하도록 해야 한다
- 인터럽트가 발생하는 경우
	- 전원에 문제 발생
	- I/O작업 완료
	- Timer 종료
	- 0으로 나눴을 때 
	- 잘못된 메모리 공간에 접근 시도
- 인터럽트 발생시 실행중인 명령어를 마무리하고 프로세스를 저장한 뒤  
통제권을 받은 커널이 인터럽트를 처리한다

### 시스템 콜 System Call  
- `운영체제의 커널이 제공하는 서비스`를 프로그램이 이용하고자 할 때 커널에 접근하기 위한 인터페이스  
- 시스템 콜의 유형
	- 프로세스 제어
	- 파일 조작
	- 장치 관리
	- 정보 유지
	- 통신
- 고급 언어는 시스템콜을 간접적으로 사용할 수 있는 환경을 제공한다

### 스케줄러 Scheduler  
- 스케줄러는 CPU가 작업을 멈추지 않도록 `ready queue`에서 다음 프로세스를 선택하는 역할을 한다  
`ready queue` : ready 상태인 프로세스를 담아놓은 큐

### Dispatcher
- 다음과 같은 상황에 스케줄러에 의해 선택된 프로세스에 CPU를 할당하는 역할을 한다
  - Context Switching
  - 커널모드 -> 유저모드 전환
  - 선택 프로세스를 실행시키기 적절한 위치로 이동

### 스케줄링 선점 방식
- Nonpreemptive (비선점 방식)  
	- 프로세스 상태를 자발적으로 바꾸는 방식  
	- 협력적, 느린 응답성
- Preemptive (선점 방식) 
	- Timer 종료,ready상태인 프로세스의 우선순위가 더 높은 경우 등의 이유로  
	프로세스 상태가 강제로 바뀌는 방식
	- 적극적, 강제적, 빠른 응답성, 데이터 일관성에 문제가 생길 수 있음

### 스케줄링 알고리즘
- FCFS (First Come First Served)  
: 도착 순으로 프로세스 실행

- SJF (Shortest Job First)  
: 프로세스의 `다음 CPU Burst`가 가장 짧은 프로세스부터 실행
- SRTF (Shortest Remaining Time First)  
: `남은 CPU Burst`가 가장 짧은 프로세스부터 실행 (SJF + 선점 방식)
- Priority  
: 우선순위가 높은 순으로 프로세스 실행  
  ```
  프로세스 실행중에 새로운 프로세스가 들어올 경우 ?
  비선점 스케줄링 방식이면 프로세스가 끝난 후 적용
  선점 스케줄링 방식이면 프로세스 우선순위를 비교 후 실행
  ```
- RR (Round Robin)  
: Time Slice로 나눠진 CPU Time을 번갈아가면서 프로세스 실행

- MultiLevel Queue  
: 프로세스들을 그룹화해서 그룹마다 큐를 두는 방식


---

#### Context ?  
- PCB에 저장되는 CPU가 프로세스를 실행하기 위한 프로세스의 정보

#### PCB (Process Control Block) ?
- 프로세스 생성시 만들어지며 주 기억장치에 유지 되는 '상태 정보를 저장하는 구조체'
- Context Switching을 위해 필요하고 다음과 같은 정보들이 저장된다
  <details>
  <summary>펼쳐보기</summary>
  
  - PID : 프로세스 고유 ID
  - 상태 : 프로세스 상태 (준비, 대기, 실행)
  - 포인터 : 부모 / 자식 / 현재 위치 / 할당된 각 자원 에 대한 주소 기억
  - CPU 레지스터 관련 정보 
  - 주 기억 장치 관리 정보
  - 스케줄링 및 프로세스 우선 순위
  - CPU 이용 시간, 실제 이용 시간
  - 입출력 상태 정보
  </details>

#### Overhead ?  
- Context Switching에 필요한 시간이나 메모리 자원

### 그래서 Context Switching이란?

---
- 인터럽트 요청에 의해 현재 프로세스의 정보를 PCB에 저장하고 다음 프로세스를 수행하도록  
새로운 프로세스의 상태 또는 레지스터 값이 담긴 PCB를 읽어서 교체하는 작업이다.  
- CPU는 PCB를 교체할 때 아무런 작업을 하지 못하기 때문에 오버헤드가 발생하고 이는 성능 하락의 원인이 된다

#### Context Switching 발생시기
- 입출력 하드웨어 인터럽트
- CPU 사용 시간 만료
- 자식 프로세스 생성
- 인터럽트 처리를 기다릴 때 

#### Overhead를 줄이려면?
- 프로세스를 처리하는 CPU의 갯수를 늘린다
- 멀티 프로그래밍의 정도를 낮춰 문맥 교환 발생 빈도를 낮춘다
- 멀티 스레드를 이용한다
